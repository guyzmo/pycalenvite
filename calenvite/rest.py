#!/usr/bin/env python3

"""
Pycalenvite application

Usage:
    calenvite [-v]

Parameters:
    -v,--verbose           Set verbose output.
    -h,--help              This message.
    -V,--version           Show version.

"""

import os, sys

from functools import update_wrapper

from isodate import parse_duration, parse_datetime, \
        duration_isoformat as iso_td, datetime_isoformat as iso_dt
from isodate.isoerror import ISO8601Error
from datetime import datetime, timedelta

from docopt import docopt

from flask import Flask, request, render_template, make_response, send_from_directory
from flask.json import JSONEncoder
from flask_restful import Resource, Api
from flask_webpack import Webpack
from flask_cors import CORS, cross_origin

from arrow import Arrow
from calenvite.calenvite import Calenvite
from calenvite.exceptions import ParseError, MissingArgumentError, MisformattedError, ResourceNotFound, ResourceConflict

import logging
log = logging.getLogger('calenvite.rest')


class AutoJSONEncoder(JSONEncoder): # pragma: no cover
    def default(self, obj):
        if hasattr(obj, '__json__'):
            return obj.__json__()
        elif isinstance(obj, datetime):
            return iso_dt(obj)
        elif isinstance(obj, timedelta):
            return iso_td(obj)
        elif isinstance(obj, Arrow):
            return iso_dt(obj.datetime)
        else:
            return JSONEncoder.default(self, obj)


def Template(app, path): # pragma: no cover
    loader = jinja2.ChoiceLoader([
        app.jinja_loader,
        jinja2.FileSystemLoader(path),
    ])
    app.jinja_loader = loader


def WebpackWatcher(app, webpack_config='./webpack.config.js'): # pragma: no cover
    if 'WERKZEUG_RUN_MAIN' not in os.environ:
        p = Popen(['node_modules/.bin/webpack',
            '--config', webpack_config,
            '--progress',
            '--profile',
            '--colors',
            '--content-base', 'src/static',
            '--inline',
            '--watch' ]
            )

    st = time.time()
    while time.time() - st < 20: # 20s timeout
        if os.path.exists(app.config["WEBPACK_MANIFEST_PATH"]):
            break
        time.sleep(1)
    else:
        p.terminate()
        raise Exception('Timeout waiting for {} to be generated by webpack!'.format(app.config["WEBPACK_MANIFEST_PATH"]))

    return app


def _prepare_iterable(it, page, per_page, ordering, search):
    if search:
        it = filter(lambda e: search in e.subject, it)

    if ordering:
        reverse = False
        if ordering.startswith('-'):
            ordering = ordering[1:]
            reverse = True
        it = sorted(it,
                key=lambda x: getattr(x, ordering, getattr(x, 'begin', 'uid')), 
                reverse=reverse
                )

    if 0 > int(per_page):
        return it

    return it[per_page*page:per_page*(page+1)]


def prepare_iterable(iterable):
    def wrapper(func):
        def func_wrapper(self, *args, **kwarg):
            prepared = _prepare_iterable(iterable(),
                page = int(request.args.get('page', 0)),
                per_page = int(request.args.get('per_page', -1)),
                ordering = request.args.get('ordering', 'begin'),
                search = request.args.get('search', None),
                )
            return func(self, prepared, *args, **kwarg)
        return update_wrapper(func_wrapper, func)
    return wrapper


def build_api(calenvite, verbose=0, testing=False):
    root = os.path.join(os.path.abspath(os.path.dirname(__file__)), '..')
    static_folder = os.path.join(root, 'static')

    app = Flask('pycalenvite', static_folder=static_folder)

    # configure custom json encoder, using __json__ method
    app.json_encoder = AutoJSONEncoder
    app.config['RESTFUL_JSON'] = dict(cls=AutoJSONEncoder)

    # Enable webpack asset tracking and availability

    # wp = Webpack()
    # app.config["REQUIREJS_BIN"] = os.path.join(root,
    #                                            '..',
    #                                            'node_modules',
    #                                            'requirejs',
    #                                            'bin',
    #                                            'r.js')
    # app.config["REQUIREJS_CONFIG"] = os.path.join(root, 'build.js')
    # app.config["REQUIREJS_RUN_IN_DEBUG"] = False

    # app.config["WEBPACK_MANIFEST_PATH"] = os.path.join(root, 'manifest.json')

    extra_files=[]

    # if verbose == 2:
    #     extra_files += [app.config["WEBPACK_MANIFEST_PATH"]]

    # Webpack(app)
    # WebpackWatcher(app, os.path.join(root, 'webpack.config.js'))

    # Enable CORS for the app
    CORS(app, origins='*')


    '''API definition'''

    class Invitation(Resource):
        def get(self, uuid):
            '''Handles invitations

            ``GET /invitation/<uuid>``

            Returns:

                gets the subject/length details of the given invitation.
            '''
            invite = calenvite.show_invite(uuid)
            if invite is None:
                raise ResourceNotFound('Unknown invitation id.')
            return dict(subject=invite.subject,
                    length=invite.length,
                    uuid=invite.uuid)

        def create_invite(self):
            '''
            ``POST /invitation``

            creates a new invitation

            Args:

                subject: the title of the invitation
                length: the duration of the meeting to plan

            Returns:

                uuid of the event (Code: 201)
            '''
            try:
                subject = request.args['subject']
                length = parse_duration(request.args['length'])
            except KeyError as err:
                raise ParseError('Missing {} parameter for the method.'.format(err.args[0])) from err

            except ISO8601Error as err:
                raise MisformattedError('Wrong date format. It shall be ISO8601 compliant.')

            return calenvite.create_invite(subject, length), 201

        def accept_invite(self, uuid):
            '''
            ``POST /invitation/<uuid>``

            accepts an invitation

            Args:

                date: chosen date of the invitation

            Returns:

                event details (Code: 200)
            '''
            try:
                date = parse_datetime(request.args['date'])
                return calenvite.confirm_invite(uuid, date), 200
            except KeyError as err:
                raise ParseError('Missing {} parameter for the method.'.format(err.args[0])) from err
            except ISO8601Error as err:
                raise MisformattedError('Wrong date format. It shall be ISO8601 compliant.') from err

        def post(self, uuid=None):
            if uuid is None:
                return self.create_invite()
            else:
                return self.accept_invite(uuid)


    class InvitationList(Resource):
        @prepare_iterable(lambda: calenvite.invites)
        def get(self, invites):
            '''Returns the list of all the pending invitations

            ``GET /invitation/list``

            Args:

                page and per_page: Pagination of the results
                ordering: order listing based on parameters of the event
                          (prepend ``-`` to reverse results)
                search: filter results based on the subject field

            Returns:

                list of ``PendingEvent``: uuid, subject and length

            '''
            return invites, 200


    class CalendarMeetings(Resource):
        def get(self):
            '''Returns all the scheduled meetings as an ics.

            ``GET /calendar/meetings``

            Returns:

                downloadable string containing the ICS file

            TODO:
                - make it a file to download
            '''
            return str(calenvite.meetings), 200


    class CalendarSoup(Resource):
        def get(self):
            '''Returns all the busy events merged

            ``GET /calendar/soup``

            Returns:

                ICS calendar as a string

            Todo:

                Make it download as a file
            '''
            return str(calenvite.calendar), 200


    class CalendarSlots(Resource):
        def get(self):
            '''Handles calendar slots

                * ``GET /calendar/slots``

            returns the busy slots of the planning.

            Args:
                * date: ISO8601 encoded date for the start date of the period to query
                * delta: ISO8601 encoded duration for the period to query.

            Returns:

                a list of tuples marking begining and end timestamps for each busy slot.
            '''
            try:
                date = parse_datetime(request.args['date'])
                delta = parse_duration(request.args['delta'])
            except KeyError as err:
                raise ParseError('Missing {} parameter for the method.'.format(err.args[0])) from err
            except ISO8601Error as err:
                raise ParseError('Wrong date format. It shall be ISO8601 compliant.')
            return list(calenvite.get_busy_slots(date, delta)), 200


    class CalendarSubscription(Resource):
        def get(self, index):
            '''
                * ``GET /calendar/subscription/<index>

            returns the URL of the calendar at index.

            '''
            return calenvite.subscriptions[index], 200

        def post(self):
            '''Handles calendar subscriptions:

                * ``POST /calendar/subscription``

            with parameter ``url``: adds a new subscription to an ICS
            '''
            try:
                url = request.args['url']
            except KeyError as err:
                raise ParseError('Missing {} parameter for the method.'.format(err.args[0])) from err
            calenvite.subscribe(url)
            return {}, 204

        def delete(self, index):
            '''
                * ``DELETE /calendar/subscription/<index>``

            removes the calendar at index.
            '''
            raise NotImplementedError


    class CalendarSubscriptionList(Resource):
        @prepare_iterable(lambda: calenvite.subscriptions)
        def get(self, subscriptions):
            '''Handles calendar listing

                * ``GET /calendar/subscription/list``

            returns the ordered list of calendar subscriptions.
            '''
            return subscriptions, 200


    errors = {
        'ResourceNotFound': {
            'message': 'The requested resource does not exists.',
            'status': 404,
            },
        'ResourceConflict': {
            'message': 'The query cannot be fulfilled because of a conflict.',
            'status': 409,
            },
        'ParseError': {
            'message': 'Error in parsing parameter for request',
            'status': 400,
            },
        'MissingArgumentError': {
            'message': 'Missing parameter in request.',
            'status': 400,
            },
        'MisformattedError': {
            'message': 'Error parsing parameter',
            'status': 400,
            },
        }


    api = Api(app,
            errors=errors,
            )

    api.add_resource(Invitation,
            '/invitation',
            '/invitation/<string:uuid>')
    api.add_resource(InvitationList,
            '/invitation/list')
    api.add_resource(CalendarMeetings,
            '/calendar/meetings')
    api.add_resource(CalendarSoup,
            '/calendar/soup')
    api.add_resource(CalendarSlots,
            '/calendar/slots')
    api.add_resource(CalendarSubscription,
            '/calendar/subscription',
            '/calendar/subscription/<int:index>')
    api.add_resource(CalendarSubscriptionList,
            '/calendar/subscription/list')


    # @app.route('/')
    # def basic_pages(**kwargs):
    #     return render_template('index.html')

    # @app.route("/assets/<path:filename>")
    # def send_asset(filename):
    #     return send_from_directory(os.path.join(root, 'static'), filename)

    if not testing:
        app.run(debug=verbose == 2,
                extra_files=extra_files)

    return app

def main(): # pragma: no cover
    try:
        args = docopt(__doc__)
        build_api(Calenvite(), verbose=args['--verbose'])
        sys.exit(0)
    except Exception as err:
        log.error('Fatal error: {}'.format(err))
        if log_root.level == logging.DEBUG:
            log.exception('------------------------------------')
        sys.exit(1)

if __name__ == '__main__': # pragma: no cover
    main()
